<!DOCTYPE html>
<html>
<head>
    <title>Informative Showcase Algorithms</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="script.js" defer></script>
</head>

<body>
    <nav class="side-nav">
        <div class="menu-btn">
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        <div class="side-menu">
            <ul>
                <li>
                    <a href="#arrays">Arrays</a>
                    <ul>
                        <li><a href="#array-operations">Basic Operations</a></li>
                        <li><a href="#bubble-sort">Bubble Sort</a></li>
                        <li><a href="#quick-sort">Quick Sort</a></li>
                        <li><a href="#selection-sort">Selection Sort</a></li>
                        <li><a href="#counting-sort">Counting Sort</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#graphs">Graphs</a>
                    <ul>
                        <li><a href="#graph-representation">Representation</a></li>
                        <li><a href="#graph-traversal">Traversal</a>
                            <ul>
                                <li><a href="#bfs">BFS</a></li>
                                <li><a href="#dfs">DFS</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#linked-lists">Linked Lists</a>
                    <ul>
                        <li><a href="#singly-linked">Singly Linked</a></li>
                        <li><a href="#doubly-linked">Doubly Linked</a></li>
                        <li><a href="#circular-linked">Circular Linked</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#trees">Trees</a>
                    <ul>
                        <li><a href="#binary-trees">Binary Trees</a></li>
                        <li><a href="#bst">Binary Search Trees</a></li>
                        <li><a href="#avl">AVL Trees</a></li>
                        <li><a href="#red-black">Red-Black Trees</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </nav>
    <div id="wrapper">
        <header id="header">
            <div class="logo">
                <h1>I.S.A.</h1>
            </div>
            <div class="content">
                <div class="inner">
                    <h2>Informative Showcase Algorithms</h2>
                    <p>Data Structures and Algorithms</p>
                </div>
            </div>
        </header>

        <div id="main">
            <article id="arrays">
                <h2>Arrays</h2>
                <p>Arrays are fundamental data structures that store elements in contiguous memory locations. They allow for efficient access to elements using an index.</p>
                
                <h3>Example of an Array</h3>
                <p>Below is an example of a simple array:</p>
                <pre>
                [10, 20, 30, 40, 50]
                </pre>
                <p>In this array:</p>
                <ul>
                    <li>The array contains five elements: <strong>10</strong>, <strong>20</strong>, <strong>30</strong>, <strong>40</strong>, and <strong>50</strong>.</li>
                    <li>Each element can be accessed using its index, starting from <strong>0</strong>.</li>
                    <li>For example, the element at index <strong>2</strong> is <strong>30</strong>.</li>
                </ul>
            </article>

            <article id="array-operations">
                <h2>Basic Array Operations</h2>
                <div class="array-demo">
                    <div class="array-container">
                        <div id="array-display"></div>
                    </div>
                    <div class="controls">
                        <button onclick="generateRandomArrayBasic()">Generate Random Array</button>
                        <input type="number" id="arrayInput" placeholder="Enter a number">
                        <input type="number" id="arrayIndex" placeholder="Enter index">
                        <button onclick="insertElement()">Insert</button>
                        <button onclick="deleteElement()">Delete</button>
                        <button onclick="searchElement()">Search</button>
                    </div>
                    <div id="operation-result"></div>
                </div>
                <div class="code-explanation">
                    <h3>Python Implementation</h3>
                    <p>Here's how these basic array operations can be implemented in Python. In Python, lists are used as dynamic arrays and provide built-in methods for these operations:</p>
                    <pre><code class="language-python">
# Basic Array Operations in Python

# Initialize an array
array = []

# Generate random array
import random
def generate_random_array():
    return [random.randint(1, 100) for _ in range(10)]

# Insert element at specific index
def insert_element(arr, value, index):
    arr.insert(index, value)
    return arr

# Delete element at specific index
def delete_element(arr, index):
    if 0 <= index < len(arr):
        return arr.pop(index)
    return None

# Search for element
def search_element(arr, value):
    try:
        return arr.index(value)
    except ValueError:
        return -1

# Example usage:
array = generate_random_array()
print("Initial array:", array)

# Insert 42 at index 2
array = insert_element(array, 42, 2)
print("After insertion:", array)

# Delete element at index 3
deleted = delete_element(array, 3)
print("After deletion:", array)

# Search for element 42
position = search_element(array, 42)
print("42 found at index:", position)
                    </code></pre>
                </div>
            </article>

            <article id="bubble-sort">
                <h2>Bubble Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="bubble-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayBubble()">Generate Random Array</button>
                        <button onclick="bubbleSort()">Bubble Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Bubble Sort Algorithm</h3>
                    <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = bubble_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

            <article id="quick-sort">
                <h2>Quick Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="quick-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayQuick()">Generate Random Array</button>
                        <button onclick="quickSort()">Quick Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Quick Sort Algorithm</h3>
                    <p>Quick Sort is an efficient, in-place sorting algorithm that uses a divide-and-conquer strategy to sort elements.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = quick_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

            <article id="selection-sort">
                <h2>Selection Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="selection-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArraySelection()">Generate Random Array</button>
                        <button onclick="selectionSort()">Selection Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Selection Sort Algorithm</h3>
                    <p>Selection Sort is a simple sorting algorithm that divides the input into a sorted and unsorted region, and repeatedly selects the smallest element from the unsorted region to add to the sorted region.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = selection_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

            <article id="graphs">
                <h2>Graphs</h2>
                <p>Graphs are collections of nodes (or vertices) connected by edges. They are used to represent relationships between pairs of objects. Graphs can be directed or undirected, weighted or unweighted, and are widely used in various applications such as social networks, transportation systems, and network topology.</p>
                
                <h3>Example of a Graph</h3>
                <p>Below is an example of a simple undirected graph:</p>
                <pre>
                    A -- B
                    |  / |
                    | /  |
                    C -- D
                </pre>
                <p>In this graph:</p>
                <ul>
                    <li><strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>D</strong> are the vertices.</li>
                    <li>Edges connect the vertices, indicating relationships.</li>
                    <li>This graph is undirected, meaning the connections have no direction.</li>
                </ul>
            </article>

            <article id="graph-representation">
                <h2>Graph Representation</h2>
                <p>Graphs can be represented in various ways, primarily through adjacency lists and adjacency matrices:</p>
                
                <h3>1. Adjacency List</h3>
                <p>This representation uses an array of lists. Each index of the array represents a vertex, and each element in the list at that index represents the vertices that are adjacent to it. This is space-efficient for sparse graphs.</p>
                <pre>
                A: [B, C]
                B: [A, D]
                C: [A, D]
                D: [B, C]
                </pre>
                <p>In this adjacency list:</p>
                <ul>
                    <li><strong>A</strong> is connected to <strong>B</strong> and <strong>C</strong>.</li>
                    <li><strong>B</strong> is connected to <strong>A</strong> and <strong>D</strong>.</li>
                    <li><strong>C</strong> is connected to <strong>A</strong> and <strong>D</strong>.</li>
                    <li><strong>D</strong> is connected to <strong>B</strong> and <strong>C</strong>.</li>
                </ul>

                <h3>2. Adjacency Matrix</h3>
                <p>This representation uses a 2D array where the rows and columns represent vertices. A cell in the matrix is marked if there is an edge between the corresponding vertices. This is useful for dense graphs but can consume more space.</p>
                <pre>
                    A B C D
                  A 0 1 1 0
                  B 1 0 0 1
                  C 1 0 0 1
                  D 0 1 1 0
                </pre>
                <p>In this adjacency matrix:</p>
                <ul>
                    <li>A <strong>1</strong> indicates an edge between the vertices, while a <strong>0</strong> indicates no edge.</li>
                    <li>The matrix is symmetric for undirected graphs.</li>
                    <li>For example, the entry at row <strong>A</strong> and column <strong>B</strong> is <strong>1</strong>, indicating an edge between <strong>A</strong> and <strong>B</strong>.</li>
                </ul>
            </article>

            <article id="graph-traversal">
                <h2>Graph Traversal</h2>
                <p>Graph traversal is the process of visiting each vertex in a graph. There are two primary methods for traversing a graph: Breadth-First Search (BFS) and Depth-First Search (DFS).</p>
                
                <h3>Breadth-First Search (BFS)</h3>
                <p>BFS explores neighboring vertices before moving to the next level using a queue. It is effective for finding the shortest path in unweighted graphs.</p>
                <pre>
                Example Graph:
                    A
                   / \
                  B   C
                 / \   \
                D   E   F

                BFS Traversal starting from A: A, B, C, D, E, F
                </pre>
                <p>In this BFS traversal:</p>
                <ul>
                    <li>Start at the root node <strong>A</strong>.</li>
                    <li>Visit all neighbors of <strong>A</strong> (i.e., <strong>B</strong> and <strong>C</strong>).</li>
                    <li>Then visit the neighbors of <strong>B</strong> (i.e., <strong>D</strong> and <strong>E</strong>) and the neighbor of <strong>C</strong> (i.e., <strong>F</strong>).</li>
                </ul>

                <h3>Depth-First Search (DFS)</h3>
                <p>DFS explores as far as possible along each branch before backtracking using a stack. It is useful for detecting cycles and exploring connected components in a graph.</p>
                <pre>
                Example Graph:
                    A
                   / \
                  B   C
                 / \   \
                D   E   F

                DFS Traversal starting from A: A, B, D, E, C, F
                </pre>
                <p>In this DFS traversal:</p>
                <ul>
                    <li>Start at the root node <strong>A</strong>.</li>
                    <li>Go as deep as possible along the left branch (to <strong>B</strong>, then to <strong>D</strong>).</li>
                    <li>Backtrack to <strong>B</strong>, then visit <strong>E</strong>, and backtrack to <strong>A</strong>.</li>
                    <li>Finally, visit <strong>C</strong> and then <strong>F</strong>.</li>
                </ul>
            </article>

            <article id="bfs">
                <h2>Breadth-First Search (BFS)</h2>
                <p>BFS explores neighboring vertices before moving to the next level using a queue. It is effective for finding the shortest path in unweighted graphs.</p>

                <p>Here’s how BFS works:</p>
                <ol>
                    <li>Start at the root node and mark it as visited.</li>
                    <li>Enqueue the root node into a queue.</li>
                    <li>While the queue is not empty:</li>
                    <ul>
                        <li>Dequeue a node from the front of the queue.</li>
                        <li>Visit all its unvisited neighbors, mark them as visited, and enqueue them.</li>
                    </ul>
                </ol>

                <p>Example Graph:</p>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>

                <p>BFS Traversal starting from A:</p>
                <pre>
1. Start at A: [A]
2. Visit neighbors of A: [B, C]
3. Visit neighbors of B: [D, E]
4. Visit neighbor of C: [F]
                </pre>

                <p>Final BFS Traversal Order: A, B, C, D, E, F</p>

                <h4>Visualizer</h4>
                <p>Below is a simple visual representation of the BFS traversal:</p>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightblue" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>

                        <circle cx="100" cy="150" r="20" fill="lightgreen" />
                        <text x="100" y="155" text-anchor="middle" font-size="16">B</text>

                        <circle cx="300" cy="150" r="20" fill="lightgreen" />
                        <text x="300" y="155" text-anchor="middle" font-size="16">C</text>

                        <circle cx="50" cy="250" r="20" fill="lightcoral" />
                        <text x="50" y="255" text-anchor="middle" font-size="16">D</text>

                        <circle cx="150" cy="250" r="20" fill="lightcoral" />
                        <text x="150" y="255" text-anchor="middle" font-size="16">E</text>

                        <circle cx="250" cy="250" r="20" fill="lightcoral" />
                        <text x="250" y="255" text-anchor="middle" font-size="16">F</text>

                        <line x1="200" y1="70" x2="100" y2="130" stroke="black" />
                        <line x1="200" y1="70" x2="300" y2="130" stroke="black" />
                        <line x1="100" y1="170" x2="50" y2="230" stroke="black" />
                        <line x1="100" y1="170" x2="150" y2="230" stroke="black" />
                        <line x1="300" y1="170" x2="250" y2="230" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="dfs">
                <h2>Depth-First Search (DFS)</h2>
                <p>DFS explores as far as possible along each branch before backtracking using a stack. It is useful for detecting cycles and exploring connected components in a graph.</p>

                <p>Here’s how DFS works:</p>
                <ol>
                    <li>Start at the root node and mark it as visited.</li>
                    <li>Push the root node onto a stack.</li>
                    <li>While the stack is not empty:</li>
                    <ul>
                        <li>Pop a node from the top of the stack.</li>
                        <li>Visit all its unvisited neighbors, mark them as visited, and push them onto the stack.</li>
                    </ul>
                </ol>

                <p>Example Graph:</p>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>

                <p>DFS Traversal starting from A:</p>
                <pre>
1. Start at A: [A]
2. Visit B: [A, B]
3. Visit D: [A, B, D]
4. Backtrack to B, visit E: [A, B, E]
5. Backtrack to A, visit C: [A, C]
6. Visit F: [A, C, F]
                </pre>

                <p>Final DFS Traversal Order: A, B, D, E, C, F</p>

                <h4>Visualizer</h4>
                <p>Below is a simple visual representation of the DFS traversal:</p>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightblue" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>

                        <circle cx="100" cy="150" r="20" fill="lightgreen" />
                        <text x="100" y="155" text-anchor="middle" font-size="16">B</text>

                        <circle cx="300" cy="150" r="20" fill="lightgreen" />
                        <text x="300" y="155" text-anchor="middle" font-size="16">C</text>

                        <circle cx="50" cy="250" r="20" fill="lightcoral" />
                        <text x="50" y="255" text-anchor="middle" font-size="16">D</text>

                        <circle cx="150" cy="250" r="20" fill="lightcoral" />
                        <text x="150" y="255" text-anchor="middle" font-size="16">E</text>

                        <circle cx="250" cy="250" r="20" fill="lightcoral" />
                        <text x="250" y="255" text-anchor="middle" font-size="16">F</text>

                        <line x1="200" y1="70" x2="100" y2="130" stroke="black" />
                        <line x1="200" y1="70" x2="300" y2="130" stroke="black" />
                        <line x1="100" y1="170" x2="50" y2="230" stroke="black" />
                        <line x1="100" y1="170" x2="150" y2="230" stroke="black" />
                        <line x1="300" y1="170" x2="250" y2="230" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="shortest-path">
                <h2>Shortest Path</h2>
                <p>The shortest path from vertex D to vertex F in the Graph above is D->E->C->F, with a total path weight of 2+4+4=10. Other paths from D to F are also possible, but they have a higher total weight, so they can not be considered to be the shortest path.</p>
                <img src="SHORTESTPATH.png" alt="shortest">
            </article>


            <article id="linked-lists">
                <h2>Linked Lists</h2>
                <p>A linked list consists of nodes, where each node contains data and a pointer (or link) to the next node in the sequence.</p>
                
                <h3>Example of a Singly Linked List</h3>
                <p>Below is an example of a simple singly linked list:</p>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -> NULL
                </pre>
                <p>In this singly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to the next node in the list.</li>
                    <li>The last node points to <strong>NULL</strong>, indicating the end of the list.</li>
                </ul>
            </article>

            <article id="singly-linked">
                <h2>Singly Linked List</h2>
                <p>A singly linked list consists of nodes where each node contains data and a pointer to the next node in the sequence.</p>
                
                <h3>Example of a Singly Linked List</h3>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -> NULL
                </pre>
                <p>In this singly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to the next node in the list.</li>
                    <li>The last node points to <strong>NULL</strong>, indicating the end of the list.</li>
                </ul>
            </article>

            <article id="doubly-linked">
                <h2>Doubly Linked List</h2>
                <p>A doubly linked list consists of nodes where each node contains data and two pointers: one pointing to the next node and another pointing to the previous node.</p>
                
                <h3>Example of a Doubly Linked List</h3>
                <pre>
                NULL <- [A] <-> [B] <-> [C] <-> [D] -> NULL
                </pre>
                <p>In this doubly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to both the next and previous nodes.</li>
                    <li>The first node's previous pointer points to <strong>NULL</strong>, and the last node's next pointer points to <strong>NULL</strong>.</li>
                </ul>
            </article>

            <article id="circular-linked">
                <h2>Circular Linked List</h2>
                <p>A circular linked list is a variation where the last node points back to the first node, forming a circle.</p>
                
                <h3>Example of a Circular Linked List</h3>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -+
                          ^                     |
                          +---------------------+
                </pre>
                <p>In this circular linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>The last node points back to the head, creating a circular structure.</li>
                    <li>This allows for continuous traversal of the list without encountering <strong>NULL</strong>.</li>
                </ul>
            </article>

            <article id="trees">
                <h2>Trees</h2>
                <p>A tree is a non-linear data structure in which a collection of elements known as nodes are connected to each other via edges such that there exists exactly one path between any two nodes.</p>
                
                <h3>Example of a Binary Tree</h3>
                <p>Below is an example of a simple binary tree:</p>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>
                <p>In this binary tree:</p>
                <ul>
                    <li><strong>A</strong> is the root node.</li>
                    <li><strong>B</strong> and <strong>C</strong> are the children of <strong>A</strong>.</li>
                    <li><strong>D</strong> and <strong>E</strong> are the children of <strong>B</strong>.</li>
                    <li><strong>F</strong> is the child of <strong>C</strong>.</li>
                </ul>
            </article>

            <article id="binary-trees">
                <h2>Binary Trees</h2>
                <p>A Binary Tree is a type of tree data structure where each node can have a maximum of two child nodes, a left child node and a right child node. </p>
                <img src="BINARYTREE.png" alt="shortest">
            </article>

            <article id="bst">
                <h2>Binary Search Trees</h2>
                <p>A Binary Search Tree is a Binary Tree where every node's left child has a lower value, and every node's right child has a higher value.</p>
                <img src="dst.png" alt="bst">
            </article>

            <article id="avl">
                <h2>AVL Trees</h2>
                <p>AVL trees are self-balancing, which means that the tree height is kept to a minimum so that a very fast runtime is guaranteed for searching, inserting and deleting nodes</p>
                <img src="avl.png" alt="avl">
            </article>

            <article id="red-black">
                <h2>Red-Black Trees</h2>
                <p>AVL trees are self-balancing, which means that the tree height is kept to a minimum so that a very fast runtime is guaranteed for searching, inserting and deleting nodes</p>
                <img src="redblacktree.png" alt="reblack">
            </article>

            <article id="counting-sort">
                <h2>Counting Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="counting-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayCounting()">Generate Random Array</button>
                        <button onclick="countingSort()">Counting Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Counting Sort Algorithm</h3>
                    <p>Counting Sort is an integer sorting algorithm that counts the occurrences of each value in the input array and uses this information to place each value in its correct position.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for num in arr:
        count[num] += 1
    
    sorted_arr = []
    for i, cnt in enumerate(count):
        sorted_arr.extend([i] * cnt)
    
    return sorted_arr

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = counting_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

        </div>

        <footer id="footer">
            <p>&copy; XYRB</p>
        </footer>
    </div>

    <div id="bg"></div>
</body>
</html>
