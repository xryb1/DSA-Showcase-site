<!DOCTYPE html>
<html>
<head>
    <title>Informative Showcase Algorithms</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="script.js" defer></script>
</head>

<body>
    <nav class="side-nav">
        <div class="menu-btn">
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        <div class="side-menu">
            <ul>
                <li>
                    <a href="#arrays">Arrays</a>
                    <ul>
                        <li><a href="#array-operations">Basic Operations</a></li>
                        <li><a href="#bubble-sort">Bubble Sort</a></li>
                        <li><a href="#quick-sort">Quick Sort</a></li>
                        <li><a href="#selection-sort">Selection Sort</a></li>
                        <li><a href="#counting-sort">Counting Sort</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#graphs">Graphs</a>
                    <ul>
                        <li><a href="#graph-representation">Representation</a></li>
                        <li><a href="#graph-traversal">Traversal</a>
                            <ul>
                                <li><a href="#bfs">BFS</a></li>
                                <li><a href="#dfs">DFS</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <a href="#linked-lists">Linked Lists</a>
                    <ul>
                        <li><a href="#singly-linked">Singly Linked</a></li>
                        <li><a href="#doubly-linked">Doubly Linked</a></li>
                        <li><a href="#circular-linked">Circular Linked</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#trees">Trees</a>
                    <ul>
                        <li><a href="#binary-tree">Binary Trees</a></li>
                        <li><a href="#binary-search-tree">Binary Search Trees</a></li>
                        <li><a href="#avl-tree">AVL Trees</a></li>
                        <li><a href="#red-black-tree">Red-Black Trees</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </nav>
    <div id="wrapper">
        <header id="header">
            <div class="logo">
                <h1>I.S.A.</h1>
            </div>
            <div class="content">
                <div class="inner">
                    <h2>Informative Showcase Algorithms</h2>
                    <p>Data Structures and Algorithms</p>
                </div>
            </div>
        </header>

        <div id="main">
            <article id="arrays">
                <h2>Arrays</h2>
                <p>Arrays are fundamental data structures that store elements in contiguous memory locations. They allow for efficient access to elements using an index.</p>
                
                <h3>Example of an Array</h3>
                <p>Below is an example of a simple array:</p>
                <pre>
                [10, 20, 30, 40, 50]
                </pre>
                <p>In this array:</p>
                <ul>
                    <li>The array contains five elements: <strong>10</strong>, <strong>20</strong>, <strong>30</strong>, <strong>40</strong>, and <strong>50</strong>.</li>
                    <li>Each element can be accessed using its index, starting from <strong>0</strong>.</li>
                    <li>For example, the element at index <strong>2</strong> is <strong>30</strong>.</li>
                </ul>
            </article>

            <article id="array-operations">
                <h2>Basic Array Operations</h2>
                <div class="array-demo">
                    <div class="array-container">
                        <div id="array-display"></div>
                    </div>
                    <div class="controls">
                        <button onclick="generateRandomArrayBasic()">Generate Random Array</button>
                        <input type="number" id="arrayInput" placeholder="Enter a number">
                        <input type="number" id="arrayIndex" placeholder="Enter index">
                        <button onclick="insertElement()">Insert</button>
                        <button onclick="deleteElement()">Delete</button>
                        <button onclick="searchElement()">Search</button>
                    </div>
                    <div id="operation-result"></div>
                </div>
                <div class="code-explanation">
                    <h3>Python Implementation</h3>
                    <p>Here's how these basic array operations can be implemented in Python. In Python, lists are used as dynamic arrays and provide built-in methods for these operations:</p>
                    <pre><code class="language-python">
                        # Basic Array Operations in Python

                        # Initialize an array
                        array = []

                        # Generate random array
                        import random
                        def generate_random_array():
                            return [random.randint(1, 100) for _ in range(10)]

                        # Insert element at specific index
                        def insert_element(arr, value, index):
                            arr.insert(index, value)
                            return arr

                        # Delete element at specific index
                        def delete_element(arr, index):
                            if 0 <= index < len(arr):
                                return arr.pop(index)
                            return None

                        # Search for element
                        def search_element(arr, value):
                            try:
                                return arr.index(value)
                            except ValueError:
                                return -1

                        # Example usage:
                        array = generate_random_array()
                        print("Initial array:", array)

                        # Insert 42 at index 2
                        array = insert_element(array, 42, 2)
                        print("After insertion:", array)

                        # Delete element at index 3
                        deleted = delete_element(array, 3)
                        print("After deletion:", array)

                        # Search for element 42
                        position = search_element(array, 42)
                        print("42 found at index:", position)
                    </code></pre>
                </div>

                <div class="code-explanation">
                    <h3>Pseudocode</h3>
                    <p>Below is the pseudocode that explains the basic array operations:</p>
                    <pre><code class="language-text">
                        # Pseudocode for Basic Array Operations

                        # Initialize an array
                        array = []

                        # Function to generate a random array of 10 integers between 1 and 100
                        FUNCTION generate_random_array():
                            array = []
                            FOR i FROM 1 TO 10:
                            random_value = RANDOM_INTEGER_BETWEEN(1, 100)
                            array.APPEND(random_value)
                            RETURN array

                        # Function to insert an element at a specific index in the array
                        FUNCTION insert_element(array, value, index):
                            array.INSERT(index, value)
                            RETURN array

                        # Function to delete an element at a specific index in the array
                        FUNCTION delete_element(array, index):
                            IF index >= 0 AND index < LENGTH(array):
                            removed_value = array.POP(index)
                            RETURN removed_value
                            ELSE:
                            RETURN NULL  # Indicates no element was removed

                        # Function to search for an element in the array and return its index
                        FUNCTION search_element(array, value):
                            TRY:
                            position = array.FIND_INDEX(value)
                            RETURN position
                            EXCEPT VALUE_NOT_FOUND:
                            RETURN -1  # If the value is not found, return -1

                        # Main Program Execution

                        # Generate a random array and print it
                        array = generate_random_array()
                        PRINT("Initial array:", array)

                        # Insert the number 42 at index 2 and print the updated array
                        array = insert_element(array, 42, 2)
                        PRINT("After insertion:", array)

                        # Delete an element at index 3 and print the updated array
                        deleted_value = delete_element(array, 3)
                        PRINT("After deletion:", array)

                        # Search for the value 42 in the array and print its position
                        position = search_element(array, 42)
                        PRINT("42 found at index:", position)
                    </code></pre>
                </div>
            </article>

            <article id="bubble-sort">
                <h2>Bubble Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="bubble-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayBubble()">Generate Random Array</button>
                        <button onclick="bubbleSort()">Bubble Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Bubble Sort Algorithm</h3>
                    <p>Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
            def bubble_sort(arr):
                n = len(arr)
                for i in range(n - 1):
                for j in range(0, n - i - 1):
                if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                return arr
            
            # Example usage:
            arr = [64, 34, 25, 12, 22, 11, 90]
            sorted_arr = bubble_sort(arr)
            print("Sorted array:", sorted_arr)
                    </code></pre>
                    
                    <h3>Pseudocode</h3>
                    <pre><code>
            FUNCTION bubble_sort(array):
                # Get the length of the array
                n = LENGTH(array)
                
                # Outer loop for each pass
                FOR i FROM 0 TO n - 2:
                    # Inner loop to compare adjacent elements
                    FOR j FROM 0 TO n - i - 2:
                    # If the current element is greater than the next element, swap them
                    IF array[j] > array[j + 1]:
                    TEMP = array[j]
                    array[j] = array[j + 1]
                    array[j + 1] = TEMP
            RETURN array
            
            # Example usage:
            array = [64, 34, 25, 12, 22, 11, 90]
            sorted_array = bubble_sort(array)
            PRINT("Sorted array:", sorted_array)
                    </code></pre>
                </div>
            </article>

            <article id="quick-sort">
                <h2>Quick Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="quick-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayQuick()">Generate Random Array</button>
                        <button onclick="quickSort()">Quick Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Quick Sort Algorithm</h3>
                    <p>Quick Sort is an efficient, in-place sorting algorithm that uses a divide-and-conquer strategy to sort elements.</p>
                    
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
            def quick_sort(arr):
                if len(arr) <= 1:
                    return arr
                
                pivot = arr[len(arr) // 2]
                left = [x for x in arr if x < pivot]
                middle = [x for x in arr if x == pivot]
                right = [x for x in arr if x > pivot]
                
                return quick_sort(left) + middle + quick_sort(right)
            
            # Example usage:
            arr = [64, 34, 25, 12, 22, 11, 90]
            sorted_arr = quick_sort(arr)
            print("Sorted array:", sorted_arr)
                                </code></pre>
                    
                    <h4>Pseudocode</h4>
                    <pre><code class="language-plaintext">
            FUNCTION quick_sort(array):
                # Base case: If the array has one or zero elements, it is already sorted
                IF LENGTH(array) <= 1:
                RETURN array
                
                # Choose a pivot element (in this case, the middle element)
                pivot = array[LENGTH(array) // 2]
                
                # Partition the array into three parts:
                # 1. Left: elements less than the pivot
                # 2. Middle: elements equal to the pivot
                # 3. Right: elements greater than the pivot
                left = [x FOR x IN array IF x < pivot]
                middle = [x FOR x IN array IF x == pivot]
                right = [x FOR x IN array IF x > pivot]
                
                # Recursively sort the left and right partitions and combine them with the middle
                RETURN quick_sort(left) + middle + quick_sort(right)
            
            # Example usage:
            array = [64, 34, 25, 12, 22, 11, 90]
            sorted_array = quick_sort(array)
            PRINT("Sorted array:", sorted_array)
                 </code></pre>
                </div>
            </article>
            

            <article id="selection-sort">
                <h2>Selection Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="selection-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArraySelection()">Generate Random Array</button>
                        <button onclick="selectionSort()">Selection Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Selection Sort Algorithm</h3>
                    <p>Selection Sort is a simple sorting algorithm that divides the input into a sorted and unsorted region, and repeatedly selects the smallest element from the unsorted region to add to the sorted region.</p>
                    
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
            def selection_sort(arr):
                n = len(arr)
                for i in range(n):
                min_idx = i
                for j in range(i + 1, n):
                if arr[j] < arr[min_idx]:
                min_idx = j
                arr[i], arr[min_idx] = arr[min_idx], arr[i]
                return arr
            
            # Example usage:
            arr = [64, 34, 25, 12, 22, 11, 90]
            sorted_arr = selection_sort(arr)
            print("Sorted array:", sorted_arr)
                    </code></pre>
            
                    <h3>Pseudocode</h3>
                    <pre><code class="language-plaintext">
            FUNCTION selection_sort(array):
                # Get the length of the<article id="selection-sort">
                <h2>Selection Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="selection-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArraySelection()">Generate Random Array</button>
                        <button onclick="selectionSort()">Selection Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Selection Sort Algorithm</h3>
                    <p>Selection Sort is a simple sorting algorithm that divides the input into a sorted and unsorted region, and repeatedly selects the smallest element from the unsorted region to add to the sorted region.</p>
                    
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
            def selection_sort(arr):
                n = len(arr)
                for i in range(n):
                min_idx = i
                for j in range(i + 1, n):
                if arr[j] < arr[min_idx]:
                min_idx = j
                arr[i], arr[min_idx] = arr[min_idx], arr[i]
                return arr
            
            # Example usage:
            arr = [64, 34, 25, 12, 22, 11, 90]
            sorted_arr = selection_sort(arr)
            print("Sorted array:", sorted_arr)
                    </code></pre>
            
                    <h4>Pseudocode for Selection Sort</h4>
                    <pre><code class="language-plaintext">
            FUNCTION selection_sort(array):
                # Get the length of the array
                n = LENGTH(array)
                
                # Iterate over each element in the array
                FOR i = 0 TO n - 1:
                    # Assume the current element is the minimum
                    min_idx = i
                    
                    # Find the smallest element in the remaining unsorted part
                    FOR j = i + 1 TO n - 1:
                        IF array[j] < array[min_idx]:
                        # Update the index of the minimum element
                        min_idx = j
                    
                    # Swap the current element with the minimum element found
                    SWAP array[i] WITH array[min_idx]
                
                # Return the sorted array
                RETURN array
            
            # Example usage:
            array = [64, 34, 25, 12, 22, 11, 90]
            sorted_array = selection_sort(array)
            PRINT("Sorted array:", sorted_array)
                    </code></pre>
                </div>
            </article>
            
            
            array
                n = LENGTH(array)
                
                # Iterate over each element in the array
                FOR i = 0 TO n - 1:
                # Assume the current element is the minimum
                min_idx = i
                    
                # Find the smallest element in the remaining unsorted part
                FOR j = i + 1 TO n - 1:
                IF array[j] < array[min_idx]:
                # Update the index of the minimum element
                min_idx = j
                    
                # Swap the current element with the minimum element found
                SWAP array[i] WITH array[min_idx]
                
                # Return the sorted array
                RETURN array
            
            # Example usage:
            array = [64, 34, 25, 12, 22, 11, 90]
            sorted_array = selection_sort(array)
            PRINT("Sorted array:", sorted_array)
                    </code></pre>
                </div>
            </article>
            

            <article id="graphs">
                <h2>Graphs</h2>
                <p>Graphs are collections of nodes (or vertices) connected by edges. They are used to represent relationships between pairs of objects. Graphs can be directed or undirected, weighted or unweighted, and are widely used in various applications such as social networks, transportation systems, and network topology.</p>
                
                <h3>Example of a Graph</h3>
                <p>Below is an example of a simple undirected graph:</p>
                <pre>
                    A -- B
                    |  / |
                    | /  |
                    C -- D
                </pre>
                <p>In this graph:</p>
                <ul>
                    <li><strong>A</strong>, <strong>B</strong>, <strong>C</strong>, and <strong>D</strong> are the vertices.</li>
                    <li>Edges connect the vertices, indicating relationships.</li>
                    <li>This graph is undirected, meaning the connections have no direction.</li>
                </ul>
            </article>

            <article id="graph-representation">
                <h2>Graph Representation</h2>
                <p>Graphs can be represented in various ways, primarily through adjacency lists and adjacency matrices:</p>
                
                <h3>1. Adjacency List</h3>
                <p>This representation uses an array of lists. Each index of the array represents a vertex, and each element in the list at that index represents the vertices that are adjacent to it. This is space-efficient for sparse graphs.</p>
                <pre>
                A: [B, C]
                B: [A, D]
                C: [A, D]
                D: [B, C]
                </pre>
                <p>In this adjacency list:</p>
                <ul>
                    <li><strong>A</strong> is connected to <strong>B</strong> and <strong>C</strong>.</li>
                    <li><strong>B</strong> is connected to <strong>A</strong> and <strong>D</strong>.</li>
                    <li><strong>C</strong> is connected to <strong>A</strong> and <strong>D</strong>.</li>
                    <li><strong>D</strong> is connected to <strong>B</strong> and <strong>C</strong>.</li>
                </ul>

                <h3>2. Adjacency Matrix</h3>
                <p>This representation uses a 2D array where the rows and columns represent vertices. A cell in the matrix is marked if there is an edge between the corresponding vertices. This is useful for dense graphs but can consume more space.</p>
                <pre>
                    A B C D
                  A 0 1 1 0
                  B 1 0 0 1
                  C 1 0 0 1
                  D 0 1 1 0
                </pre>
                <p>In this adjacency matrix:</p>
                <ul>
                    <li>A <strong>1</strong> indicates an edge between the vertices, while a <strong>0</strong> indicates no edge.</li>
                    <li>The matrix is symmetric for undirected graphs.</li>
                    <li>For example, the entry at row <strong>A</strong> and column <strong>B</strong> is <strong>1</strong>, indicating an edge between <strong>A</strong> and <strong>B</strong>.</li>
                </ul>
            </article>

            <article id="graph-traversal">
                <h2>Graph Traversal</h2>
                <p>Graph traversal is the process of visiting each vertex in a graph. There are two primary methods for traversing a graph: Breadth-First Search (BFS) and Depth-First Search (DFS).</p>
                
                <h3>Breadth-First Search (BFS)</h3>
                <p>BFS explores neighboring vertices before moving to the next level using a queue. It is effective for finding the shortest path in unweighted graphs.</p>
                <pre>
                Example Graph:
                    A
                   / \
                  B   C
                 / \   \
                D   E   F

                BFS Traversal starting from A: A, B, C, D, E, F
                </pre>
                <p>In this BFS traversal:</p>
                <ul>
                    <li>Start at the root node <strong>A</strong>.</li>
                    <li>Visit all neighbors of <strong>A</strong> (i.e., <strong>B</strong> and <strong>C</strong>).</li>
                    <li>Then visit the neighbors of <strong>B</strong> (i.e., <strong>D</strong> and <strong>E</strong>) and the neighbor of <strong>C</strong> (i.e., <strong>F</strong>).</li>
                </ul>

                <h3>Depth-First Search (DFS)</h3>
                <p>DFS explores as far as possible along each branch before backtracking using a stack. It is useful for detecting cycles and exploring connected components in a graph.</p>
                <pre>
                Example Graph:
                    A
                   / \
                  B   C
                 / \   \
                D   E   F

                DFS Traversal starting from A: A, B, D, E, C, F
                </pre>
                <p>In this DFS traversal:</p>
                <ul>
                    <li>Start at the root node <strong>A</strong>.</li>
                    <li>Go as deep as possible along the left branch (to <strong>B</strong>, then to <strong>D</strong>).</li>
                    <li>Backtrack to <strong>B</strong>, then visit <strong>E</strong>, and backtrack to <strong>A</strong>.</li>
                    <li>Finally, visit <strong>C</strong> and then <strong>F</strong>.</li>
                </ul>
            </article>

            <article id="bfs">
                <h2>Breadth-First Search (BFS)</h2>
                <p>BFS explores neighboring vertices before moving to the next level using a queue. It is effective for finding the shortest path in unweighted graphs.</p>

                <p>Here’s how BFS works:</p>
                <ol>
                    <li>Start at the root node and mark it as visited.</li>
                    <li>Enqueue the root node into a queue.</li>
                    <li>While the queue is not empty:</li>
                    <ul>
                        <li>Dequeue a node from the front of the queue.</li>
                        <li>Visit all its unvisited neighbors, mark them as visited, and enqueue them.</li>
                    </ul>
                </ol>

                <p>Example Graph:</p>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>

                <p>BFS Traversal starting from A:</p>
                <pre>
1. Start at A: [A]
2. Visit neighbors of A: [B, C]
3. Visit neighbors of B: [D, E]
4. Visit neighbor of C: [F]
                </pre>

                <p>Final BFS Traversal Order: A, B, C, D, E, F</p>

                <h4>Visualizer</h4>
                <p>Below is a simple visual representation of the BFS traversal:</p>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightblue" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>

                        <circle cx="100" cy="150" r="20" fill="lightgreen" />
                        <text x="100" y="155" text-anchor="middle" font-size="16">B</text>

                        <circle cx="300" cy="150" r="20" fill="lightgreen" />
                        <text x="300" y="155" text-anchor="middle" font-size="16">C</text>

                        <circle cx="50" cy="250" r="20" fill="lightcoral" />
                        <text x="50" y="255" text-anchor="middle" font-size="16">D</text>

                        <circle cx="150" cy="250" r="20" fill="lightcoral" />
                        <text x="150" y="255" text-anchor="middle" font-size="16">E</text>

                        <circle cx="250" cy="250" r="20" fill="lightcoral" />
                        <text x="250" y="255" text-anchor="middle" font-size="16">F</text>

                        <line x1="200" y1="70" x2="100" y2="130" stroke="black" />
                        <line x1="200" y1="70" x2="300" y2="130" stroke="black" />
                        <line x1="100" y1="170" x2="50" y2="230" stroke="black" />
                        <line x1="100" y1="170" x2="150" y2="230" stroke="black" />
                        <line x1="300" y1="170" x2="250" y2="230" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="dfs">
                <h2>Depth-First Search (DFS)</h2>
                <p>DFS explores as far as possible along each branch before backtracking using a stack. It is useful for detecting cycles and exploring connected components in a graph.</p>

                <p>Here’s how DFS works:</p>
                <ol>
                    <li>Start at the root node and mark it as visited.</li>
                    <li>Push the root node onto a stack.</li>
                    <li>While the stack is not empty:</li>
                    <ul>
                        <li>Pop a node from the top of the stack.</li>
                        <li>Visit all its unvisited neighbors, mark them as visited, and push them onto the stack.</li>
                    </ul>
                </ol>

                <p>Example Graph:</p>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>

                <p>DFS Traversal starting from A:</p>
                <pre>
1. Start at A: [A]
2. Visit B: [A, B]
3. Visit D: [A, B, D]
4. Backtrack to B, visit E: [A, B, E]
5. Backtrack to A, visit C: [A, C]
6. Visit F: [A, C, F]
                </pre>

                <p>Final DFS Traversal Order: A, B, D, E, C, F</p>

                <h4>Visualizer</h4>
                <p>Below is a simple visual representation of the DFS traversal:</p>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightblue" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>

                        <circle cx="100" cy="150" r="20" fill="lightgreen" />
                        <text x="100" y="155" text-anchor="middle" font-size="16">B</text>

                        <circle cx="300" cy="150" r="20" fill="lightgreen" />
                        <text x="300" y="155" text-anchor="middle" font-size="16">C</text>

                        <circle cx="50" cy="250" r="20" fill="lightcoral" />
                        <text x="50" y="255" text-anchor="middle" font-size="16">D</text>

                        <circle cx="150" cy="250" r="20" fill="lightcoral" />
                        <text x="150" y="255" text-anchor="middle" font-size="16">E</text>

                        <circle cx="250" cy="250" r="20" fill="lightcoral" />
                        <text x="250" y="255" text-anchor="middle" font-size="16">F</text>

                        <line x1="200" y1="70" x2="100" y2="130" stroke="black" />
                        <line x1="200" y1="70" x2="300" y2="130" stroke="black" />
                        <line x1="100" y1="170" x2="50" y2="230" stroke="black" />
                        <line x1="100" y1="170" x2="150" y2="230" stroke="black" />
                        <line x1="300" y1="170" x2="250" y2="230" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="shortest-path">
                <h2>Shortest Path</h2>
                <p>The shortest path from vertex D to vertex F in the Graph above is D->E->C->F, with a total path weight of 2+4+4=10. Other paths from D to F are also possible, but they have a higher total weight, so they can not be considered to be the shortest path.</p>
                <img src="SHORTESTPATH.png" alt="shortest">
            </article>


            <article id="linked-lists">
                <h2>Linked Lists</h2>
                <p>A linked list consists of nodes, where each node contains data and a pointer (or link) to the next node in the sequence.</p>
                
                <h3>Example of a Singly Linked List</h3>
                <p>Below is an example of a simple singly linked list:</p>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -> NULL
                </pre>
                <p>In this singly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to the next node in the list.</li>
                    <li>The last node points to <strong>NULL</strong>, indicating the end of the list.</li>
                </ul>
            </article>

            <article id="singly-linked">
                <h2>Singly Linked List</h2>
                <p>A singly linked list consists of nodes where each node contains data and a pointer to the next node in the sequence.</p>
                
                <h3>Example of a Singly Linked List</h3>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -> NULL
                </pre>
                <p>In this singly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to the next node in the list.</li>
                    <li>The last node points to <strong>NULL</strong>, indicating the end of the list.</li>
                </ul>

                <h4>Visualizer</h4>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="300" height="100">
                        <circle cx="50" cy="50" r="20" fill="lightblue" />
                        <text x="50" y="55" text-anchor="middle" font-size="16">A</text>
                        <line x1="70" y1="50" x2="130" y2="50" stroke="black" />
                        <circle cx="150" cy="50" r="20" fill="lightblue" />
                        <text x="150" y="55" text-anchor="middle" font-size="16">B</text>
                        <line x1="170" y1="50" x2="230" y2="50" stroke="black" />
                        <circle cx="250" cy="50" r="20" fill="lightblue" />
                        <text x="250" y="55" text-anchor="middle" font-size="16">C</text>
                        <line x1="270" y1="50" x2="330" y2="50" stroke="black" />
                        <circle cx="350" cy="50" r="20" fill="lightblue" />
                        <text x="350" y="55" text-anchor="middle" font-size="16">D</text>
                        <line x1="370" y1="50" x2="400" y2="50" stroke="black" />
                        <text x="390" y="55" text-anchor="middle" font-size="16">NULL</text>
                    </svg>
                </div>
            </article>

            <article id="doubly-linked">
                <h2>Doubly Linked List</h2>
                <p>A doubly linked list consists of nodes where each node contains data and two pointers: one pointing to the next node and another pointing to the previous node.</p>
                
                <h3>Example of a Doubly Linked List</h3>
                <pre>
                NULL <- [A] <-> [B] <-> [C] <-> [D] -> NULL
                </pre>
                <p>In this doubly linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>Each node points to both the next and previous nodes.</li>
                    <li>The first node's previous pointer points to <strong>NULL</strong>, and the last node's next pointer points to <strong>NULL</strong>.</li>
                </ul>

                <h4>Visualizer</h4>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="100">
                        <text x="10" y="55" text-anchor="middle" font-size="16">NULL</text>
                        <line x1="50" y1="50" x2="100" y2="50" stroke="black" />
                        <circle cx="100" cy="50" r="20" fill="lightgreen" />
                        <text x="100" y="55" text-anchor="middle" font-size="16">A</text>
                        <line x1="120" y1="50" x2="180" y2="50" stroke="black" />
                        <circle cx="200" cy="50" r="20" fill="lightgreen" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">B</text>
                        <line x1="220" y1="50" x2="280" y2="50" stroke="black" />
                        <circle cx="300" cy="50" r="20" fill="lightgreen" />
                        <text x="300" y="55" text-anchor="middle" font-size="16">C</text>
                        <line x1="320" y1="50" x2="380" y2="50" stroke="black" />
                        <circle cx="400" cy="50" r="20" fill="lightgreen" />
                        <text x="400" y="55" text-anchor="middle" font-size="16">D</text>
                        <line x1="420" y1="50" x2="470" y2="50" stroke="black" />
                        <text x="480" y="55" text-anchor="middle" font-size="16">NULL</text>
                    </svg>
                </div>
            </article>

            <article id="circular-linked">
                <h2>Circular Linked List</h2>
                <p>A circular linked list is a variation where the last node points back to the first node, forming a circle.</p>
                
                <h3>Example of a Circular Linked List</h3>
                <pre>
                Head -> [A] -> [B] -> [C] -> [D] -+
                          ^                     |
                          +---------------------+
                </pre>
                <p>In this circular linked list:</p>
                <ul>
                    <li><strong>Head</strong> points to the first node containing <strong>A</strong>.</li>
                    <li>The last node points back to the head, creating a circular structure.</li>
                    <li>This allows for continuous traversal of the list without encountering <strong>NULL</strong>.</li>
                </ul>

                <h4>Visualizer</h4>
                <div style="display: flex; justify-content: center; align-items: center;">
                    <svg width="400" height="300">
                        <circle cx="200" cy="50" r="20" fill="lightcoral" />
                        <text x="200" y="55" text-anchor="middle" font-size="16">A</text>
                        <line x1="220" y1="50" x2="280" y2="50" stroke="black" />
                        <circle cx="300" cy="50" r="20" fill="lightcoral" />
                        <text x="300" y="55" text-anchor="middle" font-size="16">B</text>
                        <line x1="320" y1="50" x2="380" y2="50" stroke="black" />
                        <circle cx="400" cy="50" r="20" fill="lightcoral" />
                        <text x="400" y="55" text-anchor="middle" font-size="16">C</text>
                        <line x1="420" y1="50" x2="480" y2="50" stroke="black" />
                        <circle cx="500" cy="50" r="20" fill="lightcoral" />
                        <text x="500" y="55" text-anchor="middle" font-size="16">D</text>
                        <line x1="520" y1="50" x2="200" y2="50" stroke="black" />
                    </svg>
                </div>
            </article>

            <article id="binary-tree">
                <h2>Binary Tree</h2>
                <p>A binary tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.</p>
                
                <h3>Example of a Binary Tree</h3>
                <pre>
                    A
                   / \
                  B   C
                 / \   \
                D   E   F
                </pre>
                <p>In this binary tree:</p>
                <ul>
                    <li><strong>A</strong> is the root node.</li>
                    <li><strong>B</strong> and <strong>C</strong> are the children of <strong>A</strong>.</li>
                    <li><strong>D</strong> and <strong>E</strong> are the children of <strong>B</strong>.</li>
                    <li><strong>F</strong> is the child of <strong>C</strong>.</li>
                </ul>
            </article>

            <article id="binary-search-tree">
                <h2>Binary Search Tree (BST)</h2>
                <p>A binary search tree is a binary tree with the additional condition that for each node, the left subtree contains only nodes with values less than the node’s value, and the right subtree only nodes with values greater than the node’s value.</p>
                
                <h3>Example of a Binary Search Tree</h3>
                <pre>
                    4
                   / \
                  2   6
                 / \ / \
                1  3 5  7
                </pre>
                <p>In this binary search tree:</p>
                <ul>
                    <li>The left child of <strong>4</strong> is <strong>2</strong>, and the right child is <strong>6</strong>.</li>
                    <li>All values in the left subtree of <strong>4</strong> are less than <strong>4</strong>, and all values in the right subtree are greater.</li>
                </ul>
            </article>

            <article id="avl-tree">
                <h2>AVL Tree</h2>
                <p>An AVL tree is a self-balancing binary search tree where the difference in heights between the left and right subtrees for any node is at most one. This ensures O(log n) time complexity for search, insert, and delete operations.</p>
                
                <h3>Example of an AVL Tree</h3>
                <pre>
                    30
                   /  \
                  20   40
                 / \    \
                10  25   50
                </pre>
                <p>In this AVL tree:</p>
                <ul>
                    <li>The tree is balanced, with the height difference between left and right subtrees for each node being at most one.</li>
                </ul>
            </article>

            <article id="red-black-tree">
                <h2>Red-Black Tree</h2>
                <p>A red-black tree is a type of self-balancing binary search tree where each node has an extra bit for denoting the color of the node, either red or black. This ensures that the tree remains approximately balanced during insertions and deletions.</p>
                
                <h3>Example of a Red-Black Tree</h3>
                <pre>
                    10 (B)
                   /    \
                 5(R)   15(R)
                / \      \
               3(B)  7(B) 20(B)
                </pre>
                <p>In this red-black tree:</p>
                <ul>
                    <li>Every node is either red or black.</li>
                    <li>The root is always black.</li>
                    <li>Red nodes cannot have red children (no two reds in a row).</li>
                    <li>Every path from a node to its descendant NULL nodes must have the same number of black nodes.</li>
                </ul>
            </article>

            <article id="counting-sort">
                <h2>Counting Sort</h2>
                <div class="array-demo">
                    <div class="array-container" id="counting-sort-display"></div>
                    <div class="controls">
                        <button onclick="generateRandomArrayCounting()">Generate Random Array</button>
                        <button onclick="countingSort()">Counting Sort</button>
                    </div>
                </div>
                <div class="code-explanation">
                    <h3>Counting Sort Algorithm</h3>
                    <p>Counting Sort is an integer sorting algorithm that counts the occurrences of each value in the input array and uses this information to place each value in its correct position.</p>
                    <h4>Python Implementation</h4>
                    <pre><code class="language-python">
def counting_sort(arr):
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    for num in arr:
        count[num] += 1
    
    sorted_arr = []
    for i, cnt in enumerate(count):
        sorted_arr.extend([i] * cnt)
    
    return sorted_arr

# Example usage:
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = counting_sort(arr)
print("Sorted array:", sorted_arr)
                    </code></pre>
                </div>
            </article>

        </div>

        <footer id="footer">
            <p>&copy; XYRB</p>
        </footer>
    </div>

    <div id="bg"></div>
</body>
</html>
